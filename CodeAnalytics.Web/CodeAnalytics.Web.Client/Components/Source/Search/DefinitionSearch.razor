@using CodeAnalytics.Engine.Contracts.Analyze.Searchers
@using CodeAnalytics.Engine.Contracts.Archetypes.Interfaces
@using CodeAnalytics.Engine.Contracts.Archetypes.Types
@using CodeAnalytics.Web.Common.Models.Search
@using CodeAnalytics.Web.Common.Services.Search
@using CodeAnalytics.Web.Client.Components.Common.Controls
@using CodeAnalytics.Web.Client.Models.Tags
@using CodeAnalytics.Web.Common.Responses.Search
@using CodeAnalytics.Web.Common.Threading
@using CodeAnalytics.Web.Client.Components.Source.Search.Definitions

@implements IDisposable

@inject ISearchService SearchService

<div class="content">
   <div class="filter">
      <div class="types">
         <FilterTags Tags="TagTypes" SelectionChanged="@OnTypeSelectionChanged" />
      </div>
   </div>
   <div class="results">
      @foreach (var archetype in Archetypes)
      {
         <DefinitionArchetype Archetype="@archetype" Strings="@Strings" />
      }
   </div>
</div>

@code {

   private string? _searchText;
   [Parameter]
   public string? SearchText
   {
      get => _searchText;
      set
      {
         _searchText = value;
         if (_lastSearchText != _searchText)
         {
            _lastSearchText = _searchText;
            _ = InvokeAsync(OnBasicSearch);
         }
      } 
   }

   private string? _lastSearchText;
   private readonly Debouncer _debouncer = new ();

   private List<IArchetype> Archetypes => _response?.Results ?? [];
   private Dictionary<int, string> Strings => _response?.Strings ?? [];

   private BasicSearchResponse? _response;
   
   private async Task OnBasicSearch()
   {
      await _debouncer.Debounce(TimeSpan.FromMilliseconds(60), async (ct) =>
      {
         var response = await SearchService.GetBasicSearch(new BasicSearchParameters()
         {
            Options = GetOptions(),
         });
         _response = response;
      });
   }

   private async Task OnTypeSelectionChanged(List<FilterTagModel> active)
   {
      await OnBasicSearch();
   }

   public void Dispose()
   {
      _debouncer.Dispose();
   }

   private BaseSearchOptions GetOptions()
   {
      var options = new BaseSearchOptions()
      {
         SearchText = SearchText ?? string.Empty,
         CaseSensitive = false,
         Classes = _tagTypes["class"].IsActive,
         Interfaces = _tagTypes["interface"].IsActive,
         Enums = _tagTypes["enum"].IsActive,
         Structs = _tagTypes["struct"].IsActive,
         Properties = _tagTypes["property"].IsActive,
         Fields = _tagTypes["field"].IsActive,
         Methods = _tagTypes["method"].IsActive,
         Constructors = _tagTypes["constructor"].IsActive,
      };

      return options;
   }

   private List<FilterTagModel> TagTypes => _tagTypes.Values.OrderBy(x => x.Order).ToList();
   private readonly Dictionary<string, FilterTagModel> _tagTypes = new()
   {
      ["class"] = new FilterTagModel { Name = "Class", Value = "class", IsActive = true, Order = 1 },
      ["interface"] = new FilterTagModel() { Name = "Interface", Value = "interface", IsActive = true, Order = 2 },
      ["enum"] = new FilterTagModel() { Name = "Enum", Value = "enum", IsActive = true, Order = 3 },
      ["struct"] = new FilterTagModel() { Name = "Struct", Value = "struct", IsActive = true, Order = 4 },
      ["property"] = new FilterTagModel() { Name = "Property", Value = "property", IsActive = true, Order = 5 },
      ["field"] = new FilterTagModel() { Name = "Field", Value = "field", IsActive = true, Order = 6 },
      ["method"] = new FilterTagModel() { Name = "Method", Value = "method", IsActive = true, Order = 7 },
      ["constructor"] = new FilterTagModel() { Name = "Constructor", Value = "constructor", IsActive = true, Order = 8 },
   };
}