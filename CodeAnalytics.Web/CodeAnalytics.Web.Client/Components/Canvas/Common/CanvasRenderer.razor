@using System.Threading.Channels
@using CodeAnalytics.Engine.Common.Buffers
@using CodeAnalytics.Web.Common.Models.Canvas
@using CodeAnalytics.Web.Common.Models.Canvas.Interfaces
@using CodeAnalytics.Web.Common.Models.Canvas.Internal
@using CodeAnalytics.Web.Common.Threading

@implements IDisposable

@inject IJSRuntime JsRuntime

<div @ref="_parentRef" class="parent" style="@(GetCssString())">
   <canvas @ref="@_canvasRef" style="@(GetCssString())" width="@_actualWidth" height="@_actualHeight"></canvas>
</div>

@code {

   [Parameter] 
   public int Width { get; set; } = -1;
   [Parameter] 
   public int Height { get; set; } = 200;

   [Parameter] 
   public TimeSpan BatchInterval { get; set; } = TimeSpan.FromMilliseconds(10); 
   
   [Parameter, EditorRequired]
   public required Action<CanvasContext> Render { get; set; }

   private readonly SemaphoreSlim _semaphore = new(1, 1);
   private readonly Channel<ICanvasCommand> _batchChannel = Channel.CreateUnbounded<ICanvasCommand>();
   
   private ElementReference? _canvasRef;
   private ElementReference? _parentRef;
   
   private bool _disposed;

   private CanvasContext? _context;

   private int _actualWidth = -1;
   private int _actualHeight = -1;

   private readonly Debouncer _debouncerResize = new ();

   public void Rerender()
   {
      OnBaseRender(_context ?? throw new InvalidOperationException("Context not initialized yet"));
   }
   
   protected override async Task OnAfterRenderAsync(bool firstRender)
   {
      if (firstRender)
      {
         _context = new CanvasContext(_batchChannel);
         
         await JsRuntime.InvokeVoidAsync("window.initializeCanvasRenderer", CommandMapper.GetInitializeArray());
         await JsRuntime.InvokeVoidAsync("window.observeResize", _parentRef, DotNetObjectReference.Create(this), "OnResize");
         
         _ = RunBatching();
         Rerender();
      }
   }

   [JSInvokable]
   public async Task OnResize(ResizeEvent ev)
   {
      if (_disposed) return;
      
      _actualHeight = (int)ev.Height;
      _actualWidth = (int)ev.Width;

      await _debouncerResize.Debounce(TimeSpan.FromMilliseconds(10), async (ct) =>
      {
         await InvokeAsync(StateHasChanged);
         Rerender();
      });
   }

   private void OnBaseRender(CanvasContext ctx)
   {
      ctx.Width = _actualWidth;
      ctx.Height = _actualHeight;
      
      Render.Invoke(ctx);
   }

   private async Task RunBatching()
   {
      while (!_disposed && await _batchChannel.Reader.WaitToReadAsync())
      {
         await SendBatch(_batchChannel);
         await Task.Delay(BatchInterval);
      }
   }
   
   private async Task SendBatch(Channel<ICanvasCommand> channel)
   {
      if (_disposed) return;
      await _semaphore.WaitAsync();
      
      var writer = new ByteWriter(stackalloc byte[512]);
      byte[] buffer;

      try
      {
         while (channel.Reader.TryRead(out var command))
         {
            writer.WriteLittleEndian((ushort)command.CommandKind);
            command.Serialize(ref writer);
         }

         buffer = writer.WrittenSpan.ToArray();
      }
      finally
      {
         writer.Dispose();
      }

      if (buffer.Length == 0)
      {
         _semaphore.Release();
         return;
      }

      try
      {
         await JsRuntime.InvokeVoidAsync("window.handleCanvasRenderBatch", _canvasRef, buffer);
      }
      finally
      {
         _semaphore.Release();
      }
   }

   private string GetCssString()
   {
      return $"width: {GetSizeString(Width)}; height: {GetSizeString(Height)};";
   }
   
   private string GetSizeString(int size)
   {
      return size == -1 ? "100%" : $"{size}px";
   }

   public void Dispose()
   {
      if (_disposed)
      {
         return;
      }
      
      _disposed = true;
      
      _semaphore.Dispose();
      _debouncerResize.Dispose();
      _batchChannel.Writer.TryComplete();
   }

}