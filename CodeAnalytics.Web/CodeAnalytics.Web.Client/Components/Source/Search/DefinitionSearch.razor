@using CodeAnalytics.Engine.Contracts.Analyze.Searchers
@using CodeAnalytics.Engine.Contracts.Archetypes.Interfaces
@using CodeAnalytics.Engine.Contracts.Archetypes.Types
@using CodeAnalytics.Web.Common.Models.Search
@using CodeAnalytics.Web.Common.Services.Search
@using CodeAnalytics.Web.Client.Components.Common.Controls
@using CodeAnalytics.Web.Client.Models.Tags
@using CodeAnalytics.Web.Common.Responses.Search
@using CodeAnalytics.Web.Common.Threading
@using CodeAnalytics.Web.Client.Components.Source.Search.Definitions
@using CodeAnalytics.Web.Common.Preferences.Interfaces
@using CodeAnalytics.Web.Common.Preferences.Search

@implements IDisposable

@inject ISearchService SearchService
@inject IPreferenceService Preferences

<div class="content">
   <div class="filter">
      <div class="types">
         <FilterTags Tags="TagTypes" SelectionChanged="@OnTypeSelectionChanged" />
      </div>
   </div>
   <div class="results">
      @foreach (var archetype in Archetypes)
      {
         <DefinitionArchetype Archetype="@archetype" Strings="@Strings" />
      }
   </div>
</div>

@code {

   private string? _searchText;
   [Parameter]
   public string? SearchText
   {
      get => _searchText;
      set
      {
         _searchText = value;
         if (_lastSearchText != _searchText)
         {
            _lastSearchText = _searchText;
            if (_initialized)
            {
               _ = InvokeAsync(OnBasicSearch);
            }
         }
      } 
   }

   [Parameter] 
   public EventCallback<string?> SearchUpdated { get; set; }

   private string? _lastSearchText = string.Empty;
   private readonly Debouncer _debouncer = new ();

   private List<IArchetype> Archetypes => _response?.Results ?? [];
   private Dictionary<int, string> Strings => _response?.Strings ?? [];

   private BasicSearchResponse? _response;
   private bool _initialized = false;

   protected override async Task OnAfterRenderAsync(bool firstRender)
   {
      if (firstRender)
      {
         await ApplyPreferences();
         await OnBasicSearch();
         _initialized = true;
      }
   }

   private async Task OnBasicSearch()
   {
      _ = Preferences.Update(await GetCurrentPreferences());
      await _debouncer.Debounce(TimeSpan.FromMilliseconds(60), async (ct) =>
      {
         var response = await SearchService.GetBasicSearch(new BasicSearchParameters()
         {
            Options = GetOptions(),
         });
         
         _response = response;
         await InvokeAsync(StateHasChanged);
      });
   }

   private async Task OnTypeSelectionChanged(List<FilterTagModel> active)
   {
      await OnBasicSearch();
   }

   public void Dispose()
   {
      _debouncer.Dispose();
   }

   private async Task ApplyPreferences()
   {
      var preference = await Preferences.GetOrCreate(GetCurrentPreferences);

      SearchText = preference.Data.SearchText;
      foreach (var (key, type) in _tagTypes)
      {
         type.IsActive = preference.Data.Types.Contains(key);
      }
      
      await SearchUpdated.InvokeAsync(SearchText);
   }

   private Task<DefinitionSearchPreference> GetCurrentPreferences()
   {
      return Task.FromResult(new DefinitionSearchPreference()
      {
         Version = Preferences.GetLatestVersion<DefinitionSearchPreference>(),
         Data = new DefinitionSearchPreferenceData()
         {
            SearchText = _lastSearchText,
            Types = TagTypes.Where(x => x.IsActive).Select(x => x.Value).ToHashSet(),
            ScrollTop = 0
         }
      });
   }

   private BaseSearchOptions GetOptions()
   {
      var options = new BaseSearchOptions()
      {
         SearchText = SearchText ?? string.Empty,
         CaseSensitive = false,
         Classes = _tagTypes["class"].IsActive,
         Interfaces = _tagTypes["interface"].IsActive,
         Enums = _tagTypes["enum"].IsActive,
         EnumValues = _tagTypes["enum-value"].IsActive,
         Structs = _tagTypes["struct"].IsActive,
         Properties = _tagTypes["property"].IsActive,
         Fields = _tagTypes["field"].IsActive,
         Methods = _tagTypes["method"].IsActive,
         Constructors = _tagTypes["constructor"].IsActive,
      };

      return options;
   }

   private List<FilterTagModel> TagTypes => _tagTypes.Values.OrderBy(x => x.Order).ToList();
   private readonly Dictionary<string, FilterTagModel> _tagTypes = new()
   {
      ["class"] = new FilterTagModel { Name = "Class", Value = "class", IsActive = true, Order = 1 },
      ["interface"] = new FilterTagModel() { Name = "Interface", Value = "interface", IsActive = true, Order = 2 },
      ["enum"] = new FilterTagModel() { Name = "Enum", Value = "enum", IsActive = true, Order = 3 },
      ["enum-value"] = new FilterTagModel() { Name = "Enum Value", Value = "enum-value", IsActive = true, Order = 4 },
      ["struct"] = new FilterTagModel() { Name = "Struct", Value = "struct", IsActive = true, Order = 5 },
      ["property"] = new FilterTagModel() { Name = "Property", Value = "property", IsActive = true, Order = 6 },
      ["field"] = new FilterTagModel() { Name = "Field", Value = "field", IsActive = true, Order = 7 },
      ["method"] = new FilterTagModel() { Name = "Method", Value = "method", IsActive = true, Order = 8 },
      ["constructor"] = new FilterTagModel() { Name = "Constructor", Value = "constructor", IsActive = true, Order = 9 },
   };
}